package com.cradle.neptune.view.ui.reading

import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.LinearLayout
import androidx.databinding.DataBindingComponent
import androidx.databinding.DataBindingUtil
import androidx.lifecycle.lifecycleScope
import androidx.lifecycle.observe
import com.cradle.neptune.R
import com.cradle.neptune.binding.FragmentDataBindingComponent
import com.cradle.neptune.databinding.FragmentSymptomsBinding
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

private const val TAG = "SymptomsFragment"

/**
 * Gather information about the patient.
 */
class SymptomsFragment : BaseFragment() {
    private var debugPeriodicPrintJob: Job? = null

    private val dataBindingComponent: DataBindingComponent = FragmentDataBindingComponent()

    // The name "FragmentSymptomsBinding" is generated by the Data Binding library.
    private var binding: FragmentSymptomsBinding? = null

    private var checkBoxes: List<CheckBox>? = null

    override fun onDestroyView() {
        super.onDestroyView()
        checkBoxes?.forEach {
            it.setOnCheckedChangeListener(null)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        binding = null
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        binding = DataBindingUtil.inflate(
            inflater,
            R.layout.fragment_symptoms,
            container,
            false,
            dataBindingComponent
        )
        return binding?.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        binding?.lifecycleOwner = viewLifecycleOwner
        binding?.viewModel = viewModel
        super.onViewCreated(view, savedInstanceState)

        val checkBoxContainer = view.findViewById<LinearLayout>(R.id.symptoms_checkbox_container)
            ?: error("no container")

        checkBoxes = view.resources.getStringArray(R.array.reading_symptoms)
            .mapIndexed { index, symptomString ->
                CheckBox(checkBoxContainer.context)
                    .apply {
                        text = symptomString
                        isChecked = viewModel.symptomsState.value?.isSymptomIndexChecked(index)
                            ?: false
                        setOnCheckedChangeListener { _, isChecked ->
                            Log.d(TAG, "DEBUG: checkbox $index is checked")
                            viewModel.setSymptomsState(index, isChecked)
                        }
                        viewModel.isInputEnabled.observe(viewLifecycleOwner) { isEnabled = it }
                    }
                    .also { checkBoxContainer.addView(it) }
            }
            .toList()

        viewModel.symptomsState.observe(viewLifecycleOwner) { newSymptomsState ->
            checkBoxes?.forEachIndexed { index, checkBox ->
                val newState = newSymptomsState.isSymptomIndexChecked(index)
                // Prevent infinite loops: Changing the checked state will trigger
                // setOnCheckedChangeListener, which can trigger a change to symptomsState LiveData.
                if (newState != checkBox.isChecked) {
                    checkBox.isChecked = newState
                }
            }
            // Disable the No symptoms CheckBox when it is selected.
            checkBoxes?.get(0)?.apply { isClickable = !isChecked }
        }

        // Need to observe so that the MediatorLiveData gets updated.
        viewModel.symptoms.observe(viewLifecycleOwner) {}

        debugPeriodicPrintJob?.cancel()
        debugPeriodicPrintJob = lifecycleScope.launch {
            while (true) {
                Log.d(TAG, "DEBUG: symptoms are: ${viewModel.symptoms.value}")
                Log.d(TAG, "DEBUG: symptoms state is: ${viewModel.symptomsState.value}")
                @Suppress("MagicNumber")
                delay(4000L)
            }
        }
    }
}
