package com.cradleplatform.neptune.view.ui.reading

import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.view.size
import androidx.databinding.DataBindingComponent
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.lifecycleScope
import com.cradleplatform.neptune.R
import com.cradleplatform.neptune.binding.FragmentDataBindingComponent
import com.cradleplatform.neptune.databinding.FragmentAdviceBinding
import com.cradleplatform.neptune.databinding.ListReadingsCardItemBinding
import com.cradleplatform.neptune.ext.hideKeyboard
import com.cradleplatform.neptune.model.Reading
import com.cradleplatform.neptune.model.RetestGroup
import com.cradleplatform.neptune.utilities.notification.NotificationManagerCustom
import com.cradleplatform.neptune.view.PatientsActivity
import com.cradleplatform.neptune.view.ReadingActivity
import com.cradleplatform.neptune.viewmodel.PatientReadingViewModel
import com.cradleplatform.neptune.viewmodel.ReadingFlowSaveResult
import com.google.android.material.dialog.MaterialAlertDialogBuilder
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.launch

@AndroidEntryPoint
class AdviceFragment : Fragment() {
    /**
     * ViewModel is scoped to the [ReadingActivity] that this Fragment is attached to; therefore,
     * this is shared by all Fragments.
     */
    private val viewModel: PatientReadingViewModel by activityViewModels()

    private val dataBindingComponent: DataBindingComponent = FragmentDataBindingComponent()

    // The name "FragmentSymptomsBinding" is generated by the Data Binding library.
    private var binding: FragmentAdviceBinding? = null

    private var savingDialog: AlertDialog? = null

    private var launchReason: ReadingActivity.LaunchReason? = null

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        binding = DataBindingUtil.inflate(
            inflater,
            R.layout.fragment_advice,
            container,
            false,
            dataBindingComponent
        )
        binding?.apply {
            lifecycleOwner = viewLifecycleOwner
            viewModel = this@AdviceFragment.viewModel
            executePendingBindings()
        }
        return binding?.root
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        super.onActivityCreated(savedInstanceState)
        launchReason = (activity as? ReadingActivity)?.getLaunchReason()
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        binding?.apply {
            launchReason = (activity as? ReadingActivity)?.getLaunchReason()
            executePendingBindings()
        }
        super.onViewCreated(view, savedInstanceState)

        viewModel.currentValidPatientAndRetestGroup.observe(viewLifecycleOwner) {
            it ?: return@observe

            setupCurrentReadingSummaryLayout(view, it.first, it.second)
            setupPreviousRetestGroupLayout(view, it.first, it.second)
        }

        viewModel.isSaving.observe(viewLifecycleOwner) { isSaving ->
            if (viewModel.isSendingReferral()) {
                // Don't show the dialog if sending a referral. The user might be trying to send a
                // referral via web without internet; what happens in that case is that the entire
                // screen flashes for a split second. Not good for people with seizures!
                return@observe
            }

            if (isSaving) {
                savingDialog = activity?.let {
                    MaterialAlertDialogBuilder(it)
                        .setTitle(R.string.fragment_advice_saving_dialog_title)
                        .setView(R.layout.dialog_loading)
                        .show()
                }
            } else {
                savingDialog?.dismiss()
            }
        }

        // Required for updates to come to these MediatorLiveData.
        viewModel.isFlaggedForFollowUp.observe(viewLifecycleOwner) {}
        viewModel.dateRecheckVitalsNeeded.observe(viewLifecycleOwner) {}

        view.findViewById<Button>(R.id.save_reading_button).setOnClickListener {
            viewModel.idlingResource?.increment()

            it.hideKeyboard()
            viewModel.setInputEnabledState(false)

            lifecycleScope.launch {
                when (val saveResult = viewModel.save()) {
                    is ReadingFlowSaveResult.SaveSuccessful -> {
                        // Recheck vitals is required, send notification in 15 minutes
                        if (saveResult != ReadingFlowSaveResult.SaveSuccessful.ReCheckNeededNow) {
                            val intent = Intent(view.context, PatientsActivity::class.java).apply {
                                flags =
                                    Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                            }
                            viewModel.patientId.value?.toInt()?.let { it1 ->
                                NotificationManagerCustom.scheduleNotification(
                                    view.context,
                                    getString(R.string.vital_recheck_notification_title, viewModel.patientName.value),
                                    getString(R.string.vital_recheck_notification_body_msg),
                                    it1,
                                    intent,
                                    resources.getInteger(R.integer.recheck_duration)
                                )
                            }
                        }

                        showStatusToast(view.context, saveResult)
                        viewModel.isSaving.removeObservers(viewLifecycleOwner)
                        savingDialog?.cancel()
                        savingDialog = null
                        activity?.finish()
                    }
                    ReadingFlowSaveResult.ReferralRequired -> {
                        launchReferralDialog()
                    }
                    else -> {
                        showStatusToast(view.context, saveResult)
                        viewModel.setInputEnabledState(true)
                    }
                }
                viewModel.idlingResource?.decrement()
            }
        }
    }

    private fun showStatusToast(context: Context, saveResult: ReadingFlowSaveResult) {
        Toast.makeText(
            context,
            getToastStatusMessage(context, saveResult),
            Toast.LENGTH_LONG
        ).show()
    }

    private fun getToastStatusMessage(context: Context, result: ReadingFlowSaveResult): String {
        launchReason ?: return context.getString(R.string.fragment_advice_toast_error)

        return when (result) {
            is ReadingFlowSaveResult.SaveSuccessful -> {
                when (launchReason) {
                    ReadingActivity.LaunchReason.LAUNCH_REASON_NEW ->
                        context.getString(R.string.fragment_advice_toast_success_new_patient)
                    ReadingActivity.LaunchReason.LAUNCH_REASON_EDIT_READING ->
                        context.getString(R.string.fragment_advice_toast_success_edit_reading)
                    else ->
                        context.getString(R.string.fragment_advice_toast_success_new_reading)
                }
            }
            ReadingFlowSaveResult.ErrorConstructing -> {
                when (launchReason) {
                    ReadingActivity.LaunchReason.LAUNCH_REASON_NEW ->
                        context.getString(R.string.fragment_advice_toast_error_new_patient)
                    ReadingActivity.LaunchReason.LAUNCH_REASON_EDIT_READING ->
                        context.getString(R.string.fragment_advice_toast_error_edit_reading)
                    else ->
                        context.getString(R.string.fragment_advice_toast_error_new_reading)
                }
            }
            ReadingFlowSaveResult.ReferralRequired -> {
                error("no toast should be showing up for this result; just the dialog appears")
            }
            ReadingFlowSaveResult.ErrorUploadingReferral -> {
                error("unreachable, because the normal save path shouldn't be uploading referrals")
            }
        }
    }

    private fun launchReferralDialog() {
        val launchReason = launchReason ?: return
        ReferralDialogFragment.makeInstance(launchReason)
            .show(parentFragmentManager, "referral_dialog")
    }

    private fun setupCurrentReadingSummaryLayout(
        view: View,
        currentReading: Reading,
        retestGroup: RetestGroup
    ) {
        check(retestGroup.size >= 1)
        check(retestGroup.readings.last().id == currentReading.id)

        val currentReadingLayout =
            view.findViewById<LinearLayout>(R.id.current_reading_summary_linear_layout) ?: return
        if (currentReadingLayout.size != 0) {
            currentReadingLayout.removeAllViews()
        }

        val binding = DataBindingUtil.inflate<ListReadingsCardItemBinding>(
            LayoutInflater.from(view.context) /* inflater */,
            R.layout.list_readings_card_item /* layoutId */,
            currentReadingLayout /* parent layout */,
            false /* attachToParent */,
            dataBindingComponent
        )
        binding.reading = retestGroup.readings.last()
        binding.analysis = retestGroup.mostRecentReadingAnalysis
        binding.executePendingBindings()
        currentReadingLayout.addView(binding.root)
    }

    private fun setupPreviousRetestGroupLayout(
        view: View,
        currentReading: Reading,
        retestGroup: RetestGroup
    ) {
        val previousReadingsLayout = view.findViewById<LinearLayout>(
            R.id.previous_readings_linear_layout
        ) ?: return

        if (previousReadingsLayout.size != 0) {
            previousReadingsLayout.removeAllViews()
        }

        val areThereNoPreviousReadings = retestGroup.size <= 1
        val visibility = if (areThereNoPreviousReadings) View.GONE else View.VISIBLE
        view.run {
            findViewById<TextView>(R.id.previous_readings_text_view)?.visibility = visibility
            findViewById<LinearLayout>(R.id.previous_readings_linear_layout)?.visibility =
                visibility
        }
        if (areThereNoPreviousReadings) {
            // We only want to show "Previous readings for patient" if they have previous readings.
            return
        }

        // The previous readings are sorted in ascending order of the date taken. Iterate through
        // it backwards so that the more recent ones are more closer to the top.
        for (i in (0 until retestGroup.size).reversed()) {
            val reading = retestGroup.readings[i]
            // Skip the most recent reading
            if (reading.id != currentReading.id && reading != currentReading) {
                val analysis = retestGroup.analyses[i]
                val binding = DataBindingUtil.inflate<ListReadingsCardItemBinding>(
                    LayoutInflater.from(view.context) /* inflater */,
                    R.layout.list_readings_card_item /* layoutId */,
                    previousReadingsLayout /* parent layout */,
                    false /* attachToParent */,
                    dataBindingComponent
                )
                binding.reading = reading
                binding.analysis = analysis
                previousReadingsLayout.addView(binding.root)
            }
        }
    }
}
